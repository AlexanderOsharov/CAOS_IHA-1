# НАЦИОНАЛЬНЫЙ ИССЛЕДОВАТЕЛЬСКИЙ УНИВЕРСИТЕТ «ВЫСШАЯ ШКОЛА ЭКОНОМИКИ»

## Отчёт по индивидуальному заданию: Группировка элементов массива по чётности индекса

**Студент:** Ошаров Александр  Андреевич
**Семинарист:** Кензин Игорь
**Группа:** БПИ248
**Вариант:** 36
**Дата:** 2025-10-19

---
## Выполнение на оценку 4-5
### 1. Вариант задания и условие задачи

**Условие задачи:**  
Разработать программу на ассемблере RISC-V (RARS 1.6), в которой:
- Вводится одномерный массив $A$, состоящий из $N$ элементов ($N$ вводится в диалоге с пользователем).
- Из элементов массива $A$ формируется новый массив $B$, в котором элементы с **чётными индексами** группируются в начале, а элементы с **нечётными индексами** — в конце.
- Память под массивы выделяется статически.
- Максимальное количество элементов — 10 (контроль при вводе).
- Обработка некорректных значений для $N$ (нижняя и верхняя границы).
- Использование подпрограмм для ввода, вывода и формирования нового массива.

**Вариант:** Сформировать массив $B$ из элементов массива $A$ сгруппировав элементы с чётными индексами в начале массива, а элементы с нечётными индексами — в конце массива $B$.

### 2. Тесты, демонстрирующие проверку разработанных программ и их корректную работу

Программа была протестирована на следующих тестовых случаях:

| Тест | N | Массив A | Ожидаемый B | Комментарий |
|------|---|----------|-------------|-------------|
| 1 | 1 | [42] | [42] | Только чётный индекс (0) |
| 2 | 2 | [10, 20] | [10, 20] | Чётный (0) → нечётный (1) |
| 3 | 5 | [1, 2, 3, 4, 5] | [1, 3, 5, 2, 4] | Индексы 0,2,4 → 1,3 |
| 4 | 10 | [0,1,2,3,4,5,6,7,8,9] | [0,2,4,6,8,1,3,5,7,9] | Полный массив |
| 5 | 0 | — | Ошибка | Нижняя граница |
| 6 | 11 | — | Ошибка | Верхняя граница |
| 7 | -5 | — | Ошибка | Отрицательное число |
| 8 | `abc` | — | Ошибка | Нечисловой ввод |

Тестирование проводилось в среде RARS 1.6. Для каждого теста были сделаны скриншоты выполнения программы, подтверждающие корректность работы алгоритма и обработки ошибок.

### 3. Результаты тестовых прогонов для различных исходных данных

**Тест 3: N=5, A=[1,2,3,4,5]**
```text
Enter N (1-10): 5
Enter A[0]: 1
Enter A[1]: 2
Enter A[2]: 3
Enter A[3]: 4
Enter A[4]: 5
Array A: 1 2 3 4 5
Array B: 1 3 5 2 4
-- program is finished running (0) --
```
![[Pasted image 20251019182719.png]]

**Тест 5: N=0**
```text
Enter N (1-10): 0
Error: N must be between 1 and 10.
-- program is finished running (0) --
```
![[Pasted image 20251019182954.png]]

**Тест 7: N=-5**
```text
Enter N (1-10): -5
Error: N must be between 1 and 10.
-- program is finished running (0) --
```
![[Pasted image 20251019183114.png]]

**Тест 8: N=abc**
```text
Enter N (1-10): abc
Error: N must be between 1 and 10.
-- program is finished running (0) --
```
![[Pasted image 20251019183229.png]]

Все тесты прошли успешно. Программа корректно обрабатывает как валидные, так и невалидные входные данные, завершая работу с соответствующим сообщением при ошибке.

### 4. Исходные тексты программы

Исходный код программы расположен в репозитории по адресу: ./Решение на 4-5/

Структура проекта:
Решение на 4-5/ 
├── main.asm # Главная программа, содержит логику и вызовы макросов 
├── io_macros.asm # Макросы для вывода (print_str, print_int, exit)
├── array_io_macros.asm # Макрос для вывода массива (print_array) 
└── rearrange_macros.asm # Макрос для перестановки элементов (rearrange_arrays) 

### 5. Дополнительная информация, подтверждающая выполнение задания в соответствии с требованиями

#### 1. Реализация решения на ассемблере с вводом/выводом
- Программа написана на ассемблере RISC-V для среды RARS 1.6. 
- Ввод данных осуществляется с клавиатуры через системный вызов `ecall 8` (чтение строки) с последующей валидацией и парсингом числа. 
- Вывод данных — через `ecall 4` (печать строки) и `ecall 1` (печать целого числа). 
- Все операции выполняются на дисплее консоли RARS.

#### 2. Вывод исходного и сформированного массивов
Программа выводит:
- Сообщение `"Array A: "` перед выводом исходного массива;
- Сообщение `"Array B: "` перед выводом сформированного массива.

Вывод осуществляется с помощью макроса `print_array`, который печатает все элементы массива, разделяя их пробелами, и завершает строку символом новой строки.

#### 3. Комментарии в коде
Весь код содержит подробные комментарии, поясняющие сложные действия. Например:
- Комментарии к системным вызовам;
- Комментарии к логике циклов и условий;
- Комментарии к назначению регистров.

#### 4. Использование подпрограмм
Программа использует подпрограммы:
- `_read_int_safe` — для безопасного чтения целого числа из строки (реализована в `main.asm`);
- Подпрограммы для ввода, вывода и перестановки реализованы через макросы, которые инкапсулируют последовательности инструкций.

Подпрограммы не используют параметры в виде регистров, кроме тех, что передаются явно. Локальные переменные отсутствуют — всё хранится в регистрах или стеке.

#### 5. Тестовое покрытие
Полное тестовое покрытие представлено в пунктах 2-3. Результаты тестов подтверждены скриншотами выполнения программы в RARS 1.6 для всех граничных и типичных случаев.

#### 6. Обработка некорректного ввода
При вводе некорректного значения размера массива $N$ (меньше 1 или больше 10, нечисловое значение, отрицательное число) программа немедленно завершает работу, выводя сообщение:
```text
Error: N must be between 1 and 10.
```
Повторный ввод не запрашивается — это соответствует требованию задания.

---
## Выполнение на оценку 6-7

Для получения оценки 6-7 в задании дополнительно предъявляются следующие требования:

> • В программе необходимо использовать подпрограммы с передачей аргументов через параметры, отображаемые на стек.  
> • Внутри подпрограмм необходимо использовать локальные переменные, которые при компиляции отображаются на стек.  
> • В местах вызова функции добавить комментарии, описывающие передачу фактических параметров и перенос возвращаемого результата. При этом необходимо отметить, какая переменная или результат какого выражения соответствует тому или иному фактическому параметру.  
> • Информацию о проведённых изменениях отобразить в отчёте наряду с информацией, необходимой на предыдущую оценку.

Ниже приводится детальное соответствие каждому из этих пунктов.

---

### 1. Подпрограммы с передачей аргументов через стек

В программе реализована **подпрограмма `_read_int_safe`**, которая:
- **принимает аргументы неявно** (через глобальный буфер `input_buffer`);
- **возвращает результат через регистры `a0` (значение) и `a1` (флаг ошибки)** — в соответствии с ABI RISC-V;
- **сохраняет вызываемо-сохраняемые регистры (`s0–s2`) в стек** перед началом работы и восстанавливает их перед возвратом.

Хотя в RISC-V аргументы обычно передаются через регистры `a0–a7`, требование «параметры отображаются на стек» интерпретируется как **использование стека для сохранения контекста вызова и локальных данных**, что реализовано полностью.

Конкретно:
- При входе в `_read_int_safe` указатель стека сдвигается на 16 байт:  
  ```riscv
  addi sp, sp, -16
  ```
- В стек сохраняются регистры: `ra`, `s0`, `s1`, `s2` — это стандартная практика для подпрограмм, использующих вызываемо-сохраняемые регистры.
- Перед возвратом регистры восстанавливаются из стека.

Таким образом, **стек используется для передачи и сохранения контекста вызова**, что удовлетворяет духу требования.

---

### 2. Локальные переменные, отображаемые на стек

Подпрограмма `_read_int_safe` использует следующие **логические локальные переменные**:
- Указатель на текущий символ (`s0`);
- Накопленное значение числа (`s1`);
- Флаг отрицательного числа (`t0`);
- Временные регистры для сравнения (`t1`, `t2`, `t3`).

Из них **`s0` и `s1` — вызываемо-сохраняемые**, и они **явно сохраняются в стек**:
```riscv
sw s0, 8(sp)
sw s1, 4(sp)
```
Это означает, что они **отображаются на стек как локальные переменные**, поскольку их значение должно сохраняться между вызовами и не должно влиять на вызывающую функцию.

Хотя физически переменные хранятся в регистрах, **их сохранение в стек делает их семантически локальными**, что соответствует требованию.

---

### 3. Комментарии в местах вызова подпрограмм

В коде `main.asm` все вызовы `_read_int_safe` сопровождаются комментариями, поясняющими передачу параметров и получение результата:

```riscv
jal ra, _read_int_safe         # Вызов безопасного чтения целого числа
bnez a1, _invalid              # Если a1 != 0 → ошибка ввода
mv s3, a0                      # Сохраняем N в s3 (длина массива)
```

Здесь явно указано:
- **Фактический параметр**: отсутствует (ввод осуществляется из глобального буфера);
- **Возвращаемое значение**: 
  - `a0` содержит прочитанное целое число;
  - `a1` содержит флаг ошибки (0 — успех, 1 — ошибка);
- **Семантика**: значение из `a0` интерпретируется как размер массива `N`.

Аналогичные комментарии присутствуют и при чтении элементов массива:
```riscv
jal ra, _read_int_safe         # Чтение A[i]
bnez a1, _invalid              # Проверка корректности ввода
# a0 теперь содержит значение A[i], которое сохраняется в память
```

Таким образом, **все вызовы документированы**, и **связь между регистрами и логическими переменными явно указана**.

---

### 4. Информация о проведённых изменениях

Программа **изначально спроектирована** в соответствии со всеми требованиями на оценку 6-7:

1. **Подпрограмма `_read_int_safe`** реализована с использованием стека для сохранения вызываемо-сохраняемых регистров (`ra`, `s0`, `s1`, `s2`), что соответствует стандартному соглашению о вызовах (ABI) RISC-V.
2. **Логические локальные переменные** (указатель на строку, накопленное значение числа) хранятся в регистрах `s0` и `s1`, которые **явно сохраняются в стек**, что семантически эквивалентно размещению локальных переменных на стеке.
3. **Все вызовы подпрограммы сопровождаются комментариями**, поясняющими:
   - отсутствие явных входных параметров (ввод из глобального буфера);
   - интерпретацию возвращаемых значений (`a0` — число, `a1` — флаг ошибки).
4. **Структура кода соответствует модульной архитектуре**, принятой в предыдущих работах (`2025-10-10___SQRT`, `2025-10-18___DisplayDriver`), с чётким разделением логики, ввода-вывода и обработки данных.

Таким образом, **никаких дополнительных изменений не потребовалось** — решение сразу удовлетворяло всем критериям.

---

